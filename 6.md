# Mechanism: Limited Direct Execution
- to virtualize the CPU, OS needs to somehow share the physical CPU
- basic idea: run one process for a little while then run another one ...
    - time sharing
- challenges:
    - performance
    - control

## Basic Technique: Limited Direct Execution
- direct execution: just run the program directly on the CPU
- OS:
    1. create entry for process list
    2. allocate memory for program
    3. program into memory
    4. set up stack with argc/argv
    5. clear registers
    6. execute call main()
    7. free memory of process
    8. remove from process list
- program:
    1. run main
    2. execute return from main
- few problems
    1. if running a program, how can the OS make sure the program doesn't do anything that we don't want it to do still running it effectively?
    2. when running a process, how does the OS stop it from running and switching to another process?

## Problem #1: Restricted Operations
- direct execution's advantage => fast
    - natively on the hardware CPU
- problem:
    - if process wishes to perform some kind of restricted operation
    - one approach: let any process do whatever it wants
        - protection lose => new processor mode: user mode
- user mode:
    - restricted in what it can do
- kernel mode:
    - the os or kenrel runs in
    - privileged operations
- user process wishes to perform some kind of privileged operation
    - modern hardware provides the ability for user programs to perform a system call
    - allows the kernel to carefully expose certain key pieces of functionality to user programs
- to execute a system call
    - trap instruction
    - jumps into the kernel and raises the privilege level to kernel mode
    - once in kthe kernel, the system can perform privileged operations
    - finished => OS calls `return-from-trap` instruction
        - returns into the calling user program while simultaneously reducing the privilege level back to user mode
- hardware needs to be careful in executing a trap
    - save enough of the caller's registers => able to return correctly when the OS issues the return-from-tramp instruction
- how does the trap know which code to run inside the OS?
    - calling process can't specify an address to jump to because allow programs to jump anywhere into the kernel is bad idea
    - kernel must carefully control what code executes upon a trap
    - kerenl set up a trap table at boot time
    - OS tells the hardware what code to run when certain exceptional events occur
    - OS informs the hardware of the locations of these trap handlers
    - a system-call number assigned to each system call
        - user code responsible for placing the desired system0call number in a register
- two phases in the lmited direct execution protocol
- first (boot time)
    - kernel init the trap table & CPU remembers its location for subsequent use
- second (running a process)
    - kernel sets up a few things before using a return-from-trap instruction to start the execution of the process
    - switches the CPU to user mode -> running the process
    - process issue a system call => traps back into the OS
        - handles it and returns control via a return-from-trap to the process
    _ process completes => OS cleans up 